//THIS FILE IS AUTOGENERATED BY GHOSTCOMPILER. DON'T MODIFY OR ALTER.
using System;
using AOT;
using Unity.Burst;
using Unity.Networking.Transport;
using Unity.NetCode.LowLevel.Unsafe;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Entities;
using Unity.Collections;
using Unity.NetCode;
using Unity.Transforms;
using Unity.Mathematics;
using ECSFrenzy;

namespace ECSFrenzy.Generated
{
    [BurstCompile]
    public struct ECSFrenzyPlayerStateGhostComponentSerializer
    {
        static ECSFrenzyPlayerStateGhostComponentSerializer()
        {
            State = new GhostComponentSerializer.State
            {
                GhostFieldsHash = 11223936245589747858,
                ExcludeFromComponentCollectionHash = 0,
                ComponentType = ComponentType.ReadWrite<ECSFrenzy.PlayerState>(),
                ComponentSize = UnsafeUtility.SizeOf<ECSFrenzy.PlayerState>(),
                SnapshotSize = UnsafeUtility.SizeOf<Snapshot>(),
                ChangeMaskBits = ChangeMaskBits,
                SendMask = GhostComponentSerializer.SendMask.Interpolated | GhostComponentSerializer.SendMask.Predicted,
                SendForChildEntities = 1,
                CopyToSnapshot =
                    new PortableFunctionPointer<GhostComponentSerializer.CopyToFromSnapshotDelegate>(CopyToSnapshot),
                CopyFromSnapshot =
                    new PortableFunctionPointer<GhostComponentSerializer.CopyToFromSnapshotDelegate>(CopyFromSnapshot),
                RestoreFromBackup =
                    new PortableFunctionPointer<GhostComponentSerializer.RestoreFromBackupDelegate>(RestoreFromBackup),
                PredictDelta = new PortableFunctionPointer<GhostComponentSerializer.PredictDeltaDelegate>(PredictDelta),
                CalculateChangeMask =
                    new PortableFunctionPointer<GhostComponentSerializer.CalculateChangeMaskDelegate>(
                        CalculateChangeMask),
                Serialize = new PortableFunctionPointer<GhostComponentSerializer.SerializeDelegate>(Serialize),
                Deserialize = new PortableFunctionPointer<GhostComponentSerializer.DeserializeDelegate>(Deserialize),
                #if UNITY_EDITOR || DEVELOPMENT_BUILD
                ReportPredictionErrors = new PortableFunctionPointer<GhostComponentSerializer.ReportPredictionErrorsDelegate>(ReportPredictionErrors),
                #endif
            };
            #if UNITY_EDITOR || DEVELOPMENT_BUILD
            State.NumPredictionErrorNames = GetPredictionErrorNames(ref State.PredictionErrorNames);
            #endif
        }
        public static readonly GhostComponentSerializer.State State;
        public struct Snapshot
        {
            public float FireballCooldownDuration;
            public float FireballCooldownTimeRemaining;
            public uint IsMoving;
            public uint DidFireball;
            public uint DidBanner;
            public uint IsChanneling;
        }
        public const int ChangeMaskBits = 6;
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CopyToFromSnapshotDelegate))]
        private static void CopyToSnapshot(IntPtr stateData, IntPtr snapshotData, int snapshotOffset, int snapshotStride, IntPtr componentData, int componentStride, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData, snapshotOffset + snapshotStride*i);
                ref var component = ref GhostComponentSerializer.TypeCast<ECSFrenzy.PlayerState>(componentData, componentStride*i);
                ref var serializerState = ref GhostComponentSerializer.TypeCast<GhostSerializerState>(stateData, 0);
                snapshot.FireballCooldownDuration = component.FireballCooldownDuration;
                snapshot.FireballCooldownTimeRemaining = component.FireballCooldownTimeRemaining;
                snapshot.IsMoving = component.IsMoving?1u:0;
                snapshot.DidFireball = component.DidFireball?1u:0;
                snapshot.DidBanner = component.DidBanner?1u:0;
                snapshot.IsChanneling = component.IsChanneling?1u:0;
            }
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CopyToFromSnapshotDelegate))]
        private static void CopyFromSnapshot(IntPtr stateData, IntPtr snapshotData, int snapshotOffset, int snapshotStride, IntPtr componentData, int componentStride, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                ref var snapshotInterpolationData = ref GhostComponentSerializer.TypeCast<SnapshotData.DataAtTick>(snapshotData, snapshotStride*i);
                ref var snapshotBefore = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotInterpolationData.SnapshotBefore, snapshotOffset);
                ref var snapshotAfter = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotInterpolationData.SnapshotAfter, snapshotOffset);
                float snapshotInterpolationFactor = snapshotInterpolationData.InterpolationFactor;
                ref var component = ref GhostComponentSerializer.TypeCast<ECSFrenzy.PlayerState>(componentData, componentStride*i);
                var deserializerState = GhostComponentSerializer.TypeCast<GhostDeserializerState>(stateData, 0);
                deserializerState.SnapshotTick = snapshotInterpolationData.Tick;
                component.FireballCooldownDuration = snapshotBefore.FireballCooldownDuration;
                component.FireballCooldownTimeRemaining = snapshotBefore.FireballCooldownTimeRemaining;
                component.IsMoving = snapshotBefore.IsMoving != 0;
                component.DidFireball = snapshotBefore.DidFireball != 0;
                component.DidBanner = snapshotBefore.DidBanner != 0;
                component.IsChanneling = snapshotBefore.IsChanneling != 0;
            }
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.RestoreFromBackupDelegate))]
        private static void RestoreFromBackup(IntPtr componentData, IntPtr backupData)
        {
            ref var component = ref GhostComponentSerializer.TypeCast<ECSFrenzy.PlayerState>(componentData, 0);
            ref var backup = ref GhostComponentSerializer.TypeCast<ECSFrenzy.PlayerState>(backupData, 0);
            component.FireballCooldownDuration = backup.FireballCooldownDuration;
            component.FireballCooldownTimeRemaining = backup.FireballCooldownTimeRemaining;
            component.IsMoving = backup.IsMoving;
            component.DidFireball = backup.DidFireball;
            component.DidBanner = backup.DidBanner;
            component.IsChanneling = backup.IsChanneling;
        }

        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.PredictDeltaDelegate))]
        private static void PredictDelta(IntPtr snapshotData, IntPtr baseline1Data, IntPtr baseline2Data, ref GhostDeltaPredictor predictor)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline1 = ref GhostComponentSerializer.TypeCast<Snapshot>(baseline1Data);
            ref var baseline2 = ref GhostComponentSerializer.TypeCast<Snapshot>(baseline2Data);
            snapshot.IsMoving = (uint)predictor.PredictInt((int)snapshot.IsMoving, (int)baseline1.IsMoving, (int)baseline2.IsMoving);
            snapshot.DidFireball = (uint)predictor.PredictInt((int)snapshot.DidFireball, (int)baseline1.DidFireball, (int)baseline2.DidFireball);
            snapshot.DidBanner = (uint)predictor.PredictInt((int)snapshot.DidBanner, (int)baseline1.DidBanner, (int)baseline2.DidBanner);
            snapshot.IsChanneling = (uint)predictor.PredictInt((int)snapshot.IsChanneling, (int)baseline1.IsChanneling, (int)baseline2.IsChanneling);
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CalculateChangeMaskDelegate))]
        private static void CalculateChangeMask(IntPtr snapshotData, IntPtr baselineData, IntPtr bits, int startOffset)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline = ref GhostComponentSerializer.TypeCast<Snapshot>(baselineData);
            uint changeMask;
            changeMask = (snapshot.FireballCooldownDuration != baseline.FireballCooldownDuration) ? 1u : 0;
            changeMask |= (snapshot.FireballCooldownTimeRemaining != baseline.FireballCooldownTimeRemaining) ? (1u<<1) : 0;
            changeMask |= (snapshot.IsMoving != baseline.IsMoving) ? (1u<<2) : 0;
            changeMask |= (snapshot.DidFireball != baseline.DidFireball) ? (1u<<3) : 0;
            changeMask |= (snapshot.DidBanner != baseline.DidBanner) ? (1u<<4) : 0;
            changeMask |= (snapshot.IsChanneling != baseline.IsChanneling) ? (1u<<5) : 0;
            GhostComponentSerializer.CopyToChangeMask(bits, changeMask, startOffset, 6);
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.SerializeDelegate))]
        private static void Serialize(IntPtr snapshotData, IntPtr baselineData, ref DataStreamWriter writer, ref NetworkCompressionModel compressionModel, IntPtr changeMaskData, int startOffset)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline = ref GhostComponentSerializer.TypeCast<Snapshot>(baselineData);
            uint changeMask = GhostComponentSerializer.CopyFromChangeMask(changeMaskData, startOffset, ChangeMaskBits);
            if ((changeMask & (1 << 0)) != 0)
                writer.WritePackedFloatDelta(snapshot.FireballCooldownDuration, baseline.FireballCooldownDuration, compressionModel);
            if ((changeMask & (1 << 1)) != 0)
                writer.WritePackedFloatDelta(snapshot.FireballCooldownTimeRemaining, baseline.FireballCooldownTimeRemaining, compressionModel);
            if ((changeMask & (1 << 2)) != 0)
                writer.WritePackedUIntDelta(snapshot.IsMoving, baseline.IsMoving, compressionModel);
            if ((changeMask & (1 << 3)) != 0)
                writer.WritePackedUIntDelta(snapshot.DidFireball, baseline.DidFireball, compressionModel);
            if ((changeMask & (1 << 4)) != 0)
                writer.WritePackedUIntDelta(snapshot.DidBanner, baseline.DidBanner, compressionModel);
            if ((changeMask & (1 << 5)) != 0)
                writer.WritePackedUIntDelta(snapshot.IsChanneling, baseline.IsChanneling, compressionModel);
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.DeserializeDelegate))]
        private static void Deserialize(IntPtr snapshotData, IntPtr baselineData, ref DataStreamReader reader, ref NetworkCompressionModel compressionModel, IntPtr changeMaskData, int startOffset)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline = ref GhostComponentSerializer.TypeCast<Snapshot>(baselineData);
            uint changeMask = GhostComponentSerializer.CopyFromChangeMask(changeMaskData, startOffset, ChangeMaskBits);
            if ((changeMask & (1 << 0)) != 0)
                snapshot.FireballCooldownDuration = reader.ReadPackedFloatDelta(baseline.FireballCooldownDuration, compressionModel);
            else
                snapshot.FireballCooldownDuration = baseline.FireballCooldownDuration;
            if ((changeMask & (1 << 1)) != 0)
                snapshot.FireballCooldownTimeRemaining = reader.ReadPackedFloatDelta(baseline.FireballCooldownTimeRemaining, compressionModel);
            else
                snapshot.FireballCooldownTimeRemaining = baseline.FireballCooldownTimeRemaining;
            if ((changeMask & (1 << 2)) != 0)
                snapshot.IsMoving = reader.ReadPackedUIntDelta(baseline.IsMoving, compressionModel);
            else
                snapshot.IsMoving = baseline.IsMoving;
            if ((changeMask & (1 << 3)) != 0)
                snapshot.DidFireball = reader.ReadPackedUIntDelta(baseline.DidFireball, compressionModel);
            else
                snapshot.DidFireball = baseline.DidFireball;
            if ((changeMask & (1 << 4)) != 0)
                snapshot.DidBanner = reader.ReadPackedUIntDelta(baseline.DidBanner, compressionModel);
            else
                snapshot.DidBanner = baseline.DidBanner;
            if ((changeMask & (1 << 5)) != 0)
                snapshot.IsChanneling = reader.ReadPackedUIntDelta(baseline.IsChanneling, compressionModel);
            else
                snapshot.IsChanneling = baseline.IsChanneling;
        }
        #if UNITY_EDITOR || DEVELOPMENT_BUILD
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.ReportPredictionErrorsDelegate))]
        private static void ReportPredictionErrors(IntPtr componentData, IntPtr backupData, ref UnsafeList<float> errors)
        {
            ref var component = ref GhostComponentSerializer.TypeCast<ECSFrenzy.PlayerState>(componentData, 0);
            ref var backup = ref GhostComponentSerializer.TypeCast<ECSFrenzy.PlayerState>(backupData, 0);
            int errorIndex = 0;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.FireballCooldownDuration - backup.FireballCooldownDuration));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.FireballCooldownTimeRemaining - backup.FireballCooldownTimeRemaining));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], (component.IsMoving != backup.IsMoving) ? 1 : 0);
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], (component.DidFireball != backup.DidFireball) ? 1 : 0);
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], (component.DidBanner != backup.DidBanner) ? 1 : 0);
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], (component.IsChanneling != backup.IsChanneling) ? 1 : 0);
            ++errorIndex;
        }
        private static int GetPredictionErrorNames(ref FixedString512 names)
        {
            int nameCount = 0;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("FireballCooldownDuration"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("FireballCooldownTimeRemaining"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("IsMoving"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("DidFireball"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("DidBanner"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("IsChanneling"));
            ++nameCount;
            return nameCount;
        }
        #endif
    }
}